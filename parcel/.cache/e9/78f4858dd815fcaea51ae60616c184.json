{"id":"index.html","dependencies":[{"name":"./app.js","dynamic":true,"resolved":"/Users/chaehyun/wk4/parcel/app.js","parent":"/Users/chaehyun/wk4/parcel/index.html"},{"name":"_css_loader","parent":"/Users/chaehyun/wk4/parcel/index.html","resolved":"/opt/homebrew/lib/node_modules/parcel-bundler/src/builtins/css-loader.js"}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>three.js webgl - percent closer soft-shadows</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0\">\n    <style>body {\n        color: #000;\n      }\n      a {\n        color: #08f;\n      }</style>\n  </head>\n\n  <body>\n    <script type=\"x-shader/x-fragment\" id=\"PCSS\">\n\n      #define LIGHT_WORLD_SIZE 0.005\n      #define LIGHT_FRUSTUM_WIDTH 3.75\n      #define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n      #define NEAR_PLANE 9.5\n\n      #define NUM_SAMPLES 17\n      #define NUM_RINGS 11\n      #define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\n      vec2 poissonDisk[NUM_SAMPLES];\n\n      void initPoissonSamples( const in vec2 randomSeed ) {\n      \tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n      \tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n      \t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n      \tfloat angle = rand( randomSeed ) * PI2;\n      \tfloat radius = INV_NUM_SAMPLES;\n      \tfloat radiusStep = radius;\n\n      \tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n      \t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n      \t\tradius += radiusStep;\n      \t\tangle += ANGLE_STEP;\n      \t}\n      }\n\n      float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n      \treturn (zReceiver - zBlocker) / zBlocker;\n      }\n\n      float findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n      \t// This uses similar triangles to compute what\n      \t// area of the shadow map we should search\n      \tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n      \tfloat blockerDepthSum = 0.0;\n      \tint numBlockers = 0;\n\n      \tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n      \t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n      \t\tif ( shadowMapDepth < zReceiver ) {\n      \t\t\tblockerDepthSum += shadowMapDepth;\n      \t\t\tnumBlockers ++;\n      \t\t}\n      \t}\n\n      \tif( numBlockers == 0 ) return -1.0;\n\n      \treturn blockerDepthSum / float( numBlockers );\n      }\n\n      float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n      \tfloat sum = 0.0;\n      \tfloat depth;\n      \t#pragma unroll_loop_start\n      \tfor( int i = 0; i < 17; i ++ ) {\n      \t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n      \t\tif( zReceiver <= depth ) sum += 1.0;\n      \t}\n      \t#pragma unroll_loop_end\n      \t#pragma unroll_loop_start\n      \tfor( int i = 0; i < 17; i ++ ) {\n      \t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n      \t\tif( zReceiver <= depth ) sum += 1.0;\n      \t}\n      \t#pragma unroll_loop_end\n      \treturn sum / ( 2.0 * float( 17 ) );\n      }\n\n      float PCSS ( sampler2D shadowMap, vec4 coords ) {\n      \tvec2 uv = coords.xy;\n      \tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n      \tinitPoissonSamples( uv );\n      \t// STEP 1: blocker search\n      \tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n      \t//There are no occluders so early out (this saves filtering)\n      \tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n      \t// STEP 2: penumbra size\n      \tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n      \tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n      \t// STEP 3: filtering\n      \t//return avgBlockerDepth;\n      \treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n      }\n    </script>\n\n    <script type=\"x-shader/x-fragment\" id=\"PCSSGetShadow\">\n\n      return PCSS( shadowMap, shadowCoord );\n    </script>\n\n    <!-- Import maps polyfill -->\n    <!-- Remove this when import maps will be widely supported -->\n    <script async=\"\" src=\"https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js\"></script>\n\n    <script type=\"importmap\">\n      {\n        \"imports\": {\n          \"three\": \"../build/three.module.js\"\n        }\n      }\n    </script>\n\n    <script src=\"/0364f57fbff2fabbe941ed20c328ef1a.js\"></script>\n  </body>\n</html>\n"},"sourceMaps":null,"error":null,"hash":"e48dc5e2a90954c1878500b51f2ace18","cacheData":{"env":{}}}